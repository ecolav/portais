const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const { chainwayApi } = require('chainway-rfid');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

// Configura√ß√£o CORS
app.use(cors());
app.use(express.json());

// Configura√ß√£o padr√£o do leitor RFID (pode ser alterada via formul√°rio)
let rfidConfig = {
  ip: '192.168.99.201', // IP padr√£o da antena
  port: 8888,
  power: 20,
  antennas: [1, 2, 3, 4],
  soundEnabled: true
};

const PORT = 3001;

// Vari√°veis globais para controle
let isConnected = false;
let isReading = false;
let totalReadings = 0;
let uniqueTIDs = new Set(); // Contar TIDs √∫nicos
let readings = []; // Array de leituras para hist√≥rico
let receiverAttached = false;

// Keep-alive e verifica√ß√£o de conex√£o para PORTAL (sempre ativo)
const KEEP_ALIVE_INTERVAL = 30000; // 30 segundos - apenas verifica√ß√£o
const MAX_INACTIVITY_TIME = 60000; // 60 segundos - tempo razo√°vel
const CONNECTION_CHECK_INTERVAL = 10000; // 10 segundos - verifica√ß√£o
const MAX_READINGS_HISTORY = 50; // Reduzir hist√≥rico para economizar mem√≥ria
const READING_HEALTH_CHECK_INTERVAL = 20000; // 20 segundos - verificar se est√° lendo
let keepAliveInterval = null;
let connectionCheckInterval = null;
let readingHealthCheckInterval = null;
let lastActivityTime = null;
let lastReadingTime = null;

console.log('üöÄ Servidor RFID rodando na porta', PORT);
console.log('üì° Configura√ß√£o padr√£o:', `${rfidConfig.ip}:${rfidConfig.port}`);

// Conectar ao leitor RFID usando a biblioteca chainway-rfid
function connectToRFIDReader() {
  return new Promise(async (resolve, reject) => {
    try {
      console.log(`üîå Tentando conectar ao leitor RFID: ${rfidConfig.ip}:${rfidConfig.port}`);
      await chainwayApi.connect(rfidConfig.ip, rfidConfig.port);
      isConnected = true;

      if (!receiverAttached) {
        chainwayApi.received((data) => {
          // data: { epc, tid, ant, rssi }
          const epcValue = (data && data.epc) ? String(data.epc).toUpperCase() : '';
          const tidValue = (data && data.tid) ? String(data.tid).toUpperCase() : '';
          if (tidValue) {
            uniqueTIDs.add(tidValue);
          }
          
          // Atualizar tempo de atividade quando receber dados
          lastActivityTime = Date.now();
          lastReadingTime = Date.now();

          const reading = {
            id: Date.now(),
            epc: epcValue,
            tid: tidValue,
            rssi: typeof data.rssi === 'number' ? data.rssi : 0,
            antenna: typeof data.ant === 'number' ? data.ant : 0,
            timestamp: new Date().toISOString(),
            rawData: ''
          };

          readings.push(reading);
          totalReadings++;
          if (readings.length > MAX_READINGS_HISTORY) {
            readings = readings.slice(-MAX_READINGS_HISTORY);
          }

          io.emit('rfid-reading', reading);
          io.emit('readings-update', { readings, totalReadings, uniqueTIDs: uniqueTIDs.size });
        });
        receiverAttached = true;
      }

      console.log(`‚úÖ Conectado ao leitor RFID em ${rfidConfig.ip}:${rfidConfig.port}!`);
      
      // Iniciar sistema de keep-alive
      startKeepAlive();
      startConnectionCheck();
      startReadingHealthCheck();
      
      // SEMPRE iniciar leitura automaticamente ap√≥s conectar
      try {
        await startContinuousReading();
        console.log('üöÄ Leitura iniciada automaticamente ap√≥s conex√£o');
      } catch (startError) {
        console.log('‚ö†Ô∏è Erro ao iniciar leitura autom√°tica:', startError.message);
      }
      
      resolve();
    } catch (error) {
      console.error(`‚ùå Erro na conex√£o RFID (${rfidConfig.ip}:${rfidConfig.port}):`, error.message || error);
      isConnected = false;
      reject(error);
    }
  });
}

// Sistema de keep-alive para manter conex√£o ativa
function startKeepAlive() {
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
  }
  
  keepAliveInterval = setInterval(() => {
    if (isConnected && isReading) {
      try {
        // Keep-alive simples - apenas verifica√ß√£o sem parar leitura
        lastActivityTime = Date.now();
        
        // Log reduzido para economizar mem√≥ria (a cada 10 verifica√ß√µes)
        if (totalReadings % 10 === 0) {
          console.log('üíì Keep-alive RFID - Portal sempre ativo');
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro keep-alive:', error.message);
        // Tentar reconectar se houver erro
        handleConnectionLoss();
      }
    }
  }, KEEP_ALIVE_INTERVAL);
  
  console.log('üîÑ Keep-alive simples iniciado (30s) - Portal sempre ativo');
}

// Verifica√ß√£o peri√≥dica da conex√£o
function startConnectionCheck() {
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
  }
  
  connectionCheckInterval = setInterval(async () => {
    if (isConnected) {
      try {
        // Verificar se a conex√£o ainda est√° ativa
        const currentTime = Date.now();
        if (lastActivityTime && (currentTime - lastActivityTime) > MAX_INACTIVITY_TIME) {
          console.log('‚ö†Ô∏è Inatividade detectada, verificando conex√£o...');
          await handleConnectionLoss();
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro na verifica√ß√£o de conex√£o:', error.message);
      }
    }
  }, CONNECTION_CHECK_INTERVAL);
  
  console.log('üîç Verifica√ß√£o de conex√£o otimizada iniciada (10s)');
}

// Verifica√ß√£o de sa√∫de da leitura RFID
function startReadingHealthCheck() {
  if (readingHealthCheckInterval) {
    clearInterval(readingHealthCheckInterval);
  }
  
  readingHealthCheckInterval = setInterval(async () => {
    if (isConnected && isReading) {
      try {
        const currentTime = Date.now();
        
        // Verificar se est√° lendo h√° muito tempo sem receber dados
        if (lastReadingTime && (currentTime - lastReadingTime) > 45000) { // 45 segundos
          console.log('‚ö†Ô∏è Leitura parou de funcionar - reiniciando scan...');
          
          try {
            // Tentar reiniciar o scan
            await chainwayApi.stopScan();
            await new Promise(resolve => setTimeout(resolve, 500)); // Pausa de 500ms
            await chainwayApi.startScan();
            
            lastReadingTime = Date.now();
            lastActivityTime = Date.now();
            console.log('‚úÖ Scan RFID reiniciado com sucesso');
          } catch (restartError) {
            console.log('‚ùå Erro ao reiniciar scan:', restartError.message);
            // Se falhar, tentar reconectar completamente
            await handleConnectionLoss();
          }
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro no health check de leitura:', error.message);
      }
    }
  }, READING_HEALTH_CHECK_INTERVAL);
  
  console.log('üìä Health check de leitura RFID iniciado (20s)');
}

// Tratar perda de conex√£o
async function handleConnectionLoss() {
  console.log('üîÑ Detectada perda de conex√£o, tentando reconectar...');
  
  try {
    // Parar intervalos
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
    }
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
    }
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
    }
    
    // Marcar como desconectado
    isConnected = false;
    isReading = false;
    
    // Tentar reconectar
    await connectToRFIDReader();
    
    // Se reconectou com sucesso, SEMPRE iniciar leitura automaticamente
    if (isConnected) {
      console.log('‚úÖ Reconex√£o bem-sucedida! Iniciando leitura automaticamente...');
      
      // SEMPRE iniciar leitura ap√≥s reconectar
      try {
        await startContinuousReading();
        console.log('üöÄ Leitura iniciada automaticamente ap√≥s reconex√£o');
      } catch (startError) {
        console.log('‚ö†Ô∏è Erro ao iniciar leitura autom√°tica:', startError.message);
      }
      
      // Emitir status atualizado
      io.emit('connection-status', { 
        isConnected: true,
        isReading: isReading,
        totalReadings: totalReadings,
        uniqueTIDs: uniqueTIDs.size,
        config: rfidConfig
      });
    }
  } catch (error) {
    console.error('‚ùå Falha na reconex√£o:', error.message);
    // Emitir status de desconectado
    io.emit('connection-status', { 
      isConnected: false,
      isReading: false,
      totalReadings: totalReadings,
      uniqueTIDs: uniqueTIDs.size,
      config: rfidConfig
    });
  }
}

// Iniciar leitura cont√≠nua via chainway-rfid
async function startContinuousReading() {
  if (!isConnected) {
    console.log('‚ö†Ô∏è N√£o h√° conex√£o com o leitor');
    return;
  }
  if (isReading) {
    console.log('‚ö†Ô∏è J√° est√° lendo');
    return;
  }
  try {
    console.log(`üü¢ Iniciando leitura cont√≠nua em ${rfidConfig.ip}:${rfidConfig.port}...`);
    await chainwayApi.startScan();
    isReading = true;
    lastActivityTime = Date.now(); // Atualizar tempo de atividade
    lastReadingTime = Date.now(); // Registrar in√≠cio da leitura
    console.log('‚úÖ Leitura cont√≠nua iniciada');
  } catch (error) {
    console.error('‚ùå Erro ao iniciar leitura:', error.message || error);
  }
}

// Parar leitura cont√≠nua via chainway-rfid
async function stopContinuousReading() {
  if (!isReading) {
    console.log('‚ö†Ô∏è N√£o est√° lendo');
    return;
  }
  try {
    console.log('üõë Parando leitura cont√≠nua...');
    await chainwayApi.stopScan();
    isReading = false;
    lastActivityTime = Date.now(); // Atualizar tempo de atividade
    lastReadingTime = null; // Limpar tempo de leitura
    console.log('‚úÖ Leitura cont√≠nua parada');
  } catch (error) {
    console.error('‚ùå Erro ao parar leitura:', error.message || error);
  }
}

// Desconectar do leitor via chainway-rfid
async function disconnectFromRFIDReader() {
  if (!isConnected) return;
  try {
    console.log(`üîå Desconectando do leitor RFID (${rfidConfig.ip}:${rfidConfig.port})...`);
    
    // Parar intervalos de keep-alive
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
      console.log('üîÑ Keep-alive parado');
    }
    
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
      console.log('üîç Verifica√ß√£o de conex√£o parada');
    }
    
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
      console.log('üìä Health check de leitura parado');
    }
    
    // Verificar se os m√©todos existem antes de chamar
    if (typeof chainwayApi.stopScan === 'function') {
      try {
        await chainwayApi.stopScan();
      } catch (stopError) {
        console.log('‚ö†Ô∏è Erro ao parar scan (n√£o cr√≠tico):', stopError.message);
      }
    }
    
    if (typeof chainwayApi.disconnect === 'function') {
      try {
        await chainwayApi.disconnect();
      } catch (disconnectError) {
        console.log('‚ö†Ô∏è Erro ao desconectar (n√£o cr√≠tico):', disconnectError.message);
      }
    }
    
    isReading = false;
    isConnected = false;
    lastActivityTime = null;
    console.log('‚úÖ Desconectado do leitor RFID');
  } catch (error) {
    console.error('‚ùå Erro ao desconectar:', error.message || error);
    // For√ßar desconex√£o mesmo com erro
    isReading = false;
    isConnected = false;
    lastActivityTime = null;
    
    // Limpar intervalos mesmo com erro
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
    }
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
    }
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
    }
  }
}

// Socket.IO event handlers
io.on('connection', (socket) => {
  console.log('üîå Cliente conectado:', socket.id);
  
  // Enviar status atual
  socket.emit('connection-status', { 
    isConnected: !!isConnected,
    isReading: isReading,
    totalReadings: totalReadings,
    config: rfidConfig
  });

  socket.on('connect-reader', async () => {
    try {
      await connectToRFIDReader();
      socket.emit('connection-status', { 
        isConnected: true,
        isReading: isReading,
        totalReadings: totalReadings,
        config: rfidConfig
      });
    } catch (error) {
      socket.emit('error', { message: 'Erro ao conectar: ' + error.message });
    }
  });

  socket.on('disconnect-reader', () => {
    disconnectFromRFIDReader();
    socket.emit('connection-status', { 
      isConnected: false,
      isReading: false,
      totalReadings: totalReadings,
      config: rfidConfig
    });
  });

  socket.on('start-reading', () => {
    startContinuousReading();
    socket.emit('reading-status', { isReading: true });
  });

  socket.on('stop-reading', () => {
    stopContinuousReading();
    socket.emit('reading-status', { isReading: false });
  });

  socket.on('clear-readings', () => {
    readings = [];
    totalReadings = 0;
    uniqueTIDs.clear(); // Limpar TIDs √∫nicos
    socket.emit('readings-update', { readings, totalReadings, uniqueTIDs: uniqueTIDs.size });
  });

  socket.on('disconnect', () => {
    console.log('üîå Cliente desconectado:', socket.id);
  });
});

// REST API endpoints
app.get('/api/status', (req, res) => {
  res.json({
    isConnected: !!isConnected,
    isReading: isReading,
    totalReadings: totalReadings,
    uniqueTIDs: uniqueTIDs.size, // Adicionar contagem de TIDs √∫nicos
    readings: readings.slice(-10), // √öltimas 10 leituras
    config: rfidConfig
  });
});

app.get('/api/readings', (req, res) => {
  res.json({
    readings: readings,
    totalReadings: totalReadings
  });
});

app.get('/api/config', (req, res) => {
  res.json(rfidConfig);
});

app.post('/api/config', async (req, res) => {
  try {
    const newConfig = req.body;
    
    // Validar configura√ß√£o
    if (newConfig.ip && !/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(newConfig.ip)) {
      return res.status(400).json({ success: false, message: 'IP inv√°lido' });
    }
    
    if (newConfig.port && (newConfig.port < 1 || newConfig.port > 65535)) {
      return res.status(400).json({ success: false, message: 'Porta inv√°lida' });
    }
    
    // Atualizar configura√ß√£o
    rfidConfig = { ...rfidConfig, ...newConfig };
    
    console.log('‚öôÔ∏è Configura√ß√£o atualizada:', rfidConfig);
    
    // Se estiver conectado, desconectar para usar nova configura√ß√£o
    if (isConnected) {
      console.log('üîÑ Reconectando com nova configura√ß√£o...');
      try {
        await disconnectFromRFIDReader();
        
        // SEMPRE reconectar e iniciar leitura automaticamente ap√≥s trocar IP
        console.log('üîÑ Reconectando automaticamente com nova configura√ß√£o...');
        try {
          await connectToRFIDReader();
          console.log('‚úÖ Reconectado e leitura iniciada automaticamente com novo IP!');
        } catch (reconnectError) {
          console.log('‚ö†Ô∏è Erro na reconex√£o autom√°tica:', reconnectError.message);
        }
      } catch (disconnectError) {
        console.log('‚ö†Ô∏è Erro na desconex√£o (n√£o cr√≠tico):', disconnectError.message);
        // Tentar reconectar mesmo com erro
        try {
          await connectToRFIDReader();
          console.log('‚úÖ Reconectado ap√≥s erro na desconex√£o!');
        } catch (reconnectError) {
          console.log('‚ùå Falha na reconex√£o:', reconnectError.message);
        }
      }
    }
    
    res.json({ success: true, message: 'Configura√ß√£o atualizada', config: rfidConfig });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar configura√ß√£o:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

app.post('/api/connect', async (req, res) => {
  try {
    await connectToRFIDReader();
    // A leitura j√° √© iniciada automaticamente na fun√ß√£o connectToRFIDReader
    res.json({ success: true, message: 'Conectado e leitura iniciada automaticamente' });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

app.post('/api/disconnect', (req, res) => {
  disconnectFromRFIDReader();
  res.json({ success: true, message: 'Desconectado do leitor RFID' });
});

app.post('/api/start-reading', (req, res) => {
  startContinuousReading();
  res.json({ success: true, message: 'Leitura iniciada' });
});

app.post('/api/stop-reading', async (req, res) => {
  try {
    await stopContinuousReading();
    
    // SEMPRE reiniciar leitura automaticamente ap√≥s parar (para portal)
    if (isConnected) {
      console.log('üîÑ Reiniciando leitura automaticamente ap√≥s parada...');
      try {
        await startContinuousReading();
        console.log('üöÄ Leitura reiniciada automaticamente');
        res.json({ success: true, message: 'Leitura parada e reiniciada automaticamente' });
      } catch (restartError) {
        console.log('‚ö†Ô∏è Erro ao reiniciar leitura:', restartError.message);
        res.json({ success: true, message: 'Leitura parada, mas falha ao reiniciar' });
      }
    } else {
      res.json({ success: true, message: 'Leitura parada' });
    }
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Limpeza peri√≥dica de mem√≥ria
function cleanupMemory() {
  // Limpar arrays antigos
  if (readings.length > MAX_READINGS_HISTORY * 2) {
    readings = readings.slice(-MAX_READINGS_HISTORY);
    console.log('üßπ Mem√≥ria limpa - hist√≥rico reduzido');
  }
  
  // For√ßar garbage collection se dispon√≠vel
  if (global.gc) {
    global.gc();
    console.log('üóëÔ∏è Garbage collection executado');
  }
}

// Limpeza a cada 5 minutos
setInterval(cleanupMemory, 300000);

// Tratamento de encerramento
process.on('SIGINT', () => {
  console.log('\nüõë Encerrando servidor...');
  stopContinuousReading();
  disconnectFromRFIDReader();
  server.close(() => {
    console.log('‚úÖ Servidor encerrado');
    process.exit(0);
  });
});

// Iniciar servidor
server.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando em http://localhost:${PORT}`);
  console.log(`üì° Configura√ß√£o inicial: ${rfidConfig.ip}:${rfidConfig.port}`);
});

