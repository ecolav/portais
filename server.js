const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const { chainwayApi } = require('chainway-rfid');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

// Configura√ß√£o CORS
app.use(cors());
app.use(express.json());

// Configura√ß√£o padr√£o do leitor RFID (pode ser alterada via formul√°rio)
let rfidConfig = {
  ip: '192.168.99.201', // IP padr√£o da antena
  port: 8888,
  power: 20,
  antennas: [1, 2, 3, 4],
  soundEnabled: true
};

const PORT = 3001;

// Vari√°veis globais para controle
let isConnected = false;
let isReading = false;
let totalReadings = 0;
let uniqueTIDs = new Set(); // Contar TIDs √∫nicos
let readings = []; // Array de leituras para hist√≥rico
let receiverAttached = false;

// Keep-alive e verifica√ß√£o de conex√£o para PORTAL (sempre ativo)
const KEEP_ALIVE_INTERVAL = 30000; // 30 segundos - apenas verifica√ß√£o
const MAX_INACTIVITY_TIME = 60000; // 60 segundos - tempo razo√°vel
const CONNECTION_CHECK_INTERVAL = 10000; // 10 segundos - verifica√ß√£o
const MAX_READINGS_HISTORY = 50; // Reduzir hist√≥rico para economizar mem√≥ria
const READING_HEALTH_CHECK_INTERVAL = 20000; // 20 segundos - verificar se est√° lendo

// Monitoramento de mem√≥ria e sa√∫de do sistema
const MEMORY_CHECK_INTERVAL = 60000; // 60 segundos
const MAX_MEMORY_USAGE = 100 * 1024 * 1024; // 100MB
const MAX_READINGS_LENGTH = 100; // M√°ximo de leituras em mem√≥ria

let keepAliveInterval = null;
let connectionCheckInterval = null;
let readingHealthCheckInterval = null;
let memoryCheckInterval = null;
let lastActivityTime = null;
let lastReadingTime = null;
let connectionAttempts = 0;
let maxConnectionAttempts = 5;
let isShuttingDown = false;

console.log('üöÄ Servidor RFID rodando na porta', PORT);
console.log('üì° Configura√ß√£o padr√£o:', `${rfidConfig.ip}:${rfidConfig.port}`);

// Comandos customizados para configura√ß√£o de pot√™ncia e antenas
const CHAINWAY_COMMANDS = {
  // Comando para ajustar pot√™ncia (0-30 dBm)
  // Formato: A5 5A 00 08 82 27 [POWER] [CHECKSUM] 0D 0A
  SET_POWER: (power) => {
    const powerByte = Math.max(0, Math.min(30, power)); // 0-30 dBm
    const checksum = (0x82 + 0x27 + powerByte) & 0xFF;
    const command = Buffer.from([0xA5, 0x5A, 0x00, 0x08, 0x82, 0x27, powerByte, checksum, 0x0D, 0x0A]);
    console.log(`  üîß Comando SET_POWER gerado:`, command);
    console.log(`  üìä Power: ${power} dBm, Byte: 0x${powerByte.toString(16).padStart(2, '0')}, Checksum: 0x${checksum.toString(16).padStart(2, '0')}`);
    return command;
  },
  
  // Comando para ativar antenas
  // Formato: A5 5A 00 08 82 28 [ANTENNA_MASK] [CHECKSUM] 0D 0A
  SET_ANTENNAS: (antennas) => {
    let antennaMask = 0;
    antennas.forEach(ant => {
      if (ant >= 1 && ant <= 4) {
        antennaMask |= (1 << (ant - 1)); // Bit 0-3 para antenas 1-4
      }
    });
    const checksum = (0x82 + 0x28 + antennaMask) & 0xFF;
    return Buffer.from([0xA5, 0x5A, 0x00, 0x08, 0x82, 0x28, antennaMask, checksum, 0x0D, 0x0A]);
  },
  
  // Comando para aplicar configura√ß√£o
  APPLY_CONFIG: Buffer.from([0xA5, 0x5A, 0x00, 0x08, 0x82, 0x29, 0x01, 0xBF, 0x0D, 0x0A])
};

// Log de debug para verificar se os comandos est√£o definidos
console.log('üîß Comandos customizados definidos:');
console.log('  - SET_POWER:', typeof CHAINWAY_COMMANDS.SET_POWER);
console.log('  - SET_ANTENNAS:', typeof CHAINWAY_COMMANDS.SET_ANTENNAS);
console.log('  - APPLY_CONFIG:', typeof CHAINWAY_COMMANDS.APPLY_CONFIG);

// Conectar ao leitor RFID usando a biblioteca chainway-rfid
async function connectToRFIDReader() {
  try {
    console.log(`üîå Tentando conectar ao leitor RFID: ${rfidConfig.ip}:${rfidConfig.port}`);
    console.log(`  ‚ö° Pot√™ncia configurada: ${rfidConfig.power} dBm`);
    console.log(`  üì° Antenas configuradas: ${rfidConfig.antennas.join(', ')}`);
    
    await chainwayApi.connect(rfidConfig.ip, rfidConfig.port);
    isConnected = true;

    if (!receiverAttached) {
      chainwayApi.received((data) => {
        try {
          // data: { epc, tid, ant, rssi }
          const epcValue = (data && data.epc) ? String(data.epc).toUpperCase() : '';
          const tidValue = (data && data.tid) ? String(data.tid).toUpperCase() : '';
          if (tidValue) {
            uniqueTIDs.add(tidValue);
          }
          
          // Atualizar tempo de atividade quando receber dados
          lastActivityTime = Date.now();
          lastReadingTime = Date.now();

          const reading = {
            id: Date.now(),
            epc: epcValue,
            tid: tidValue,
            rssi: typeof data.rssi === 'number' ? data.rssi : 0,
            antenna: typeof data.ant === 'number' ? data.ant : 0,
            timestamp: new Date().toISOString(),
            rawData: ''
          };

          readings.push(reading);
          totalReadings++;
          if (readings.length > MAX_READINGS_HISTORY) {
            readings = readings.slice(-MAX_READINGS_HISTORY);
          }

          io.emit('rfid-reading', reading);
          io.emit('readings-update', { readings, totalReadings, uniqueTIDs: uniqueTIDs.size });
          
          // Log de atividade para debug
          console.log(`üì° Tag recebida: TID=${tidValue}, EPC=${epcValue}, Antena=${reading.antenna}, RSSI=${reading.rssi}`);
        } catch (error) {
          console.error('‚ùå Erro ao processar dados RFID:', error.message);
        }
      });
      
      // Adicionar handler para eventos de desconex√£o da biblioteca
      if (typeof chainwayApi.on === 'function') {
        chainwayApi.on('disconnect', () => {
          console.log('‚ö†Ô∏è Biblioteca chainway-rfid detectou desconex√£o');
          isConnected = false;
          isReading = false;
        });
        
        chainwayApi.on('error', (error) => {
          console.error('‚ùå Erro na biblioteca chainway-rfid:', error);
        });
        
        // Adicionar handler para todos os eventos poss√≠veis
        chainwayApi.on('close', () => {
          console.log('‚ö†Ô∏è Biblioteca chainway-rfid detectou fechamento de conex√£o');
        });
        
        chainwayApi.on('end', () => {
          console.log('‚ö†Ô∏è Biblioteca chainway-rfid detectou fim de conex√£o');
        });
        
        chainwayApi.on('timeout', () => {
          console.log('‚ö†Ô∏è Biblioteca chainway-rfid detectou timeout');
        });
      }
      
      // Interceptar todas as chamadas para stopScan para debug
      if (typeof chainwayApi.stopScan === 'function') {
        const originalStopScan = chainwayApi.stopScan;
        chainwayApi.stopScan = async function(...args) {
          const stackTrace = new Error().stack;
          console.log('üö® INTERCEPTADO: chainwayApi.stopScan() chamado por:');
          console.log('  üìç Stack trace:', stackTrace);
          console.log('  üìä Status atual: isReading=', isReading);
          console.log('  üìä isConnected:', isConnected);
          
          // S√≥ permitir se for chamado explicitamente pelo usu√°rio
          if (isReading) {
            console.log('  ‚ö†Ô∏è stopScan chamado enquanto est√° lendo - investigando...');
          }
          
          return await originalStopScan.apply(this, args);
        };
      }
      
      // Interceptar o evento 'close' da biblioteca para evitar desconex√£o autom√°tica
      if (chainwayApi.client && typeof chainwayApi.client.on === 'function') {
        chainwayApi.client.on('close', (hadError) => {
          console.log('üö® INTERCEPTADO: Evento CLOSE da biblioteca chainway-rfid');
          console.log('  üìä hadError:', hadError);
          console.log('  üìä Status atual: isReading=', isReading);
          console.log('  üìä isConnected:', isConnected);
          
          // Se estiver lendo e n√£o foi erro, tentar manter a conex√£o
          if (isReading && !hadError) {
            console.log('  ‚ö†Ô∏è Conex√£o fechada durante leitura - tentando manter ativa...');
            // N√ÉO marcar como desconectado automaticamente
            // Deixar o keep-alive detectar e reconectar se necess√°rio
          }
        });
      }
      
      // Sistema de auto-restart inteligente para leitura
      let autoRestartAttempts = 0;
      const MAX_AUTO_RESTART_ATTEMPTS = 3;
      
      // Fun√ß√£o para reiniciar leitura automaticamente se necess√°rio
      async function autoRestartReading() {
        if (autoRestartAttempts >= MAX_AUTO_RESTART_ATTEMPTS) {
          console.log('‚ö†Ô∏è M√°ximo de tentativas de auto-restart atingido');
          console.log('‚ÑπÔ∏è Use "Iniciar Leitura" manualmente no frontend');
          return;
        }
        
        if (isConnected && !isReading) {
          console.log(`üîÑ Tentativa ${autoRestartAttempts + 1} de auto-restart da leitura...`);
          try {
            await startContinuousReading();
            if (isReading) {
              console.log('‚úÖ Auto-restart da leitura bem-sucedido!');
              autoRestartAttempts = 0; // Reset contador
            }
          } catch (error) {
            console.error('‚ùå Falha no auto-restart:', error.message);
            autoRestartAttempts++;
          }
        }
      }
      
      // Log de todos os m√©todos dispon√≠veis na biblioteca
      console.log('üîç M√©todos dispon√≠veis na biblioteca chainway-rfid:');
      console.log('  - connect:', typeof chainwayApi.connect);
      console.log('  - disconnect:', typeof chainwayApi.disconnect);
      console.log('  - startScan:', typeof chainwayApi.startScan);
      console.log('  - stopScan:', typeof chainwayApi.stopScan);
      console.log('  - received:', typeof chainwayApi.received);
      console.log('  - on:', typeof chainwayApi.on);
      
      receiverAttached = true;
    }

    console.log(`‚úÖ Conectado ao leitor RFID em ${rfidConfig.ip}:${rfidConfig.port}!`);
    
    // Iniciar sistema de keep-alive
    startKeepAlive();
    startConnectionCheck();
    startReadingHealthCheck();
    startMemoryCheck(); // Iniciar monitoramento de mem√≥ria
    
    // N√ÉO iniciar leitura automaticamente - apenas conectar
    console.log('‚ÑπÔ∏è Leitor conectado. Use "Iniciar Leitura" para come√ßar a ler tags.');
    
  } catch (error) {
    console.error(`‚ùå Erro na conex√£o RFID (${rfidConfig.ip}:${rfidConfig.port}):`, error.message || error);
    isConnected = false;
    throw error;
  }
}

// Sistema de keep-alive para manter conex√£o ativa
function startKeepAlive() {
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
  }
  
  keepAliveInterval = setInterval(async () => {
    if (isConnected) {
      try {
        // Apenas verificar se leitor est√° respondendo - N√ÉO enviar comandos de leitura
        console.log('üîå Verificando se leitor est√° respondendo...');
        
        // N√ÉO enviar startScan - apenas verificar conex√£o
        // O leitor j√° est√° lendo ou pausado pelo usu√°rio
        
        // Atualizar apenas lastActivityTime, N√ÉO lastReadingTime
        lastActivityTime = Date.now();
        // N√ÉO atualizar lastReadingTime aqui para evitar interferir na verifica√ß√£o de sa√∫de
        
        console.log('üíì Keep-alive RFID - Conex√£o verificada');
      } catch (error) {
        console.log('‚ö†Ô∏è Erro keep-alive:', error.message);
        // Tentar reconectar se houver erro
        handleConnectionLoss();
      }
    }
  }, KEEP_ALIVE_INTERVAL);
  
  console.log('üîÑ Keep-alive iniciado (30s) - Apenas verifica√ß√£o de conex√£o');
}

// Verifica√ß√£o peri√≥dica da conex√£o
function startConnectionCheck() {
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
  }
  
  connectionCheckInterval = setInterval(async () => {
    if (isConnected) {
      try {
        // Apenas verificar se conex√£o ainda est√° ativa - N√ÉO enviar comandos de leitura
        console.log('üîå Verificando se conex√£o ainda est√° ativa...');
        
        // N√ÉO enviar startScan - apenas verificar conex√£o
        // O leitor j√° est√° lendo ou pausado pelo usu√°rio
        
        // Verificar se a conex√£o ainda est√° ativa
        const currentTime = Date.now();
        if (lastActivityTime && (currentTime - lastActivityTime) > MAX_INACTIVITY_TIME) {
          console.log('‚ö†Ô∏è Inatividade detectada, verificando conex√£o...');
          await handleConnectionLoss();
        }
        
        // Atualizar apenas lastActivityTime, N√ÉO lastReadingTime
        lastActivityTime = Date.now();
        // N√ÉO atualizar lastReadingTime aqui para evitar interferir na verifica√ß√£o de sa√∫de
        
      } catch (error) {
        console.log('‚ö†Ô∏è Erro na verifica√ß√£o de conex√£o:', error.message);
      }
    }
  }, CONNECTION_CHECK_INTERVAL);
  
  console.log('üîç Verifica√ß√£o de conex√£o iniciada (10s) - Apenas verifica√ß√£o de atividade');
}

// Verifica√ß√£o de sa√∫de da leitura RFID
function startReadingHealthCheck() {
  if (readingHealthCheckInterval) {
    clearInterval(readingHealthCheckInterval);
  }
  
  readingHealthCheckInterval = setInterval(async () => {
    if (isConnected) {
      try {
        // Apenas verificar sa√∫de da leitura - N√ÉO enviar comandos de leitura
        console.log('üîå Verificando sa√∫de da leitura...');
        
        // N√ÉO enviar startScan - apenas verificar se est√° funcionando
        // O leitor j√° est√° lendo ou pausado pelo usu√°rio
        
        // Verificar se est√° lendo h√° muito tempo sem receber dados
        if (lastReadingTime && (Date.now() - lastReadingTime) > 45000) { // 45 segundos
          console.log('‚ö†Ô∏è Leitura parou de funcionar - mas N√ÉO reiniciando automaticamente');
          console.log('‚ÑπÔ∏è Use "Iniciar Leitura" no frontend para reiniciar manualmente');
          console.log(`  üìä Status atual: isReading=${isReading}, lastReadingTime=${lastReadingTime ? new Date(lastReadingTime).toISOString() : 'null'}`);
          
          // N√ÉO reiniciar automaticamente - deixar controle manual
          // Apenas atualizar tempos para evitar spam de logs
          lastActivityTime = Date.now();
          // N√ÉO atualizar lastReadingTime aqui para evitar loop
        }
        
        // Log de status para debug
        console.log(`  üìä Status da leitura: isReading=${isReading}, lastReadingTime=${lastReadingTime ? new Date(lastReadingTime).toISOString() : 'null'}`);
        
        // Atualizar apenas lastActivityTime, N√ÉO lastReadingTime
        lastActivityTime = Date.now();
        
      } catch (error) {
        console.log('‚ö†Ô∏è Erro no health check de leitura:', error.message);
      }
    }
  }, READING_HEALTH_CHECK_INTERVAL);
  
  console.log('üìä Health check de leitura RFID iniciado (20s) - Apenas verifica√ß√£o de sa√∫de');
}

// Fun√ß√£o para aplicar pot√™ncia em tempo real
async function applyPowerInRealTime(power) {
  try {
    console.log(`‚ö° Aplicando nova pot√™ncia: ${power} dBm`);
    
    // Verificar se h√° conex√£o
    if (!isConnected) {
      console.log('‚ö†Ô∏è N√£o h√° conex√£o com o leitor para aplicar pot√™ncia');
      // Mesmo sem conex√£o, atualizar a configura√ß√£o local
      rfidConfig.power = power;
      console.log(`‚úÖ Configura√ß√£o de pot√™ncia atualizada para ${power} dBm (ser√° aplicada na pr√≥xima conex√£o)`);
      return true;
    }
    
    // Enviar comando de pot√™ncia
    console.log(`  üîß Chamando CHAINWAY_COMMANDS.SET_POWER(${power})`);
    const powerCommand = CHAINWAY_COMMANDS.SET_POWER(power);
    console.log(`  üì° Comando de pot√™ncia gerado:`, powerCommand);
    console.log(`  üìä Tipo do comando:`, typeof powerCommand);
    console.log(`  üìä √â Buffer:`, Buffer.isBuffer(powerCommand));
    
    let commandSent = false;
    
    // Usar o m√©todo send da biblioteca se dispon√≠vel
    if (typeof chainwayApi.send === 'function') {
      try {
        await chainwayApi.send(powerCommand);
        console.log('  ‚úÖ Comando de pot√™ncia enviado via chainwayApi.send');
        commandSent = true;
      } catch (sendError) {
        console.log('  ‚ö†Ô∏è Erro no chainwayApi.send:', sendError.message);
      }
    }
    
    // Fallback para acesso direto ao socket
    if (!commandSent && chainwayApi.client && typeof chainwayApi.client.write === 'function') {
      try {
        chainwayApi.client.write(powerCommand);
        console.log('  ‚úÖ Comando de pot√™ncia enviado via socket direto');
        commandSent = true;
      } catch (writeError) {
        console.log('  ‚ö†Ô∏è Erro no socket direto:', writeError.message);
      }
    }
    
    // Fallback: tentar usar o m√©todo TCP direto
    if (!commandSent) {
      console.log('  ‚ö†Ô∏è M√©todo de envio n√£o dispon√≠vel, usando fallback TCP');
      try {
        const net = require('net');
        const tempClient = new net.Socket();
        
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            tempClient.destroy();
            reject(new Error('Timeout na conex√£o TCP'));
          }, 5000);
          
          tempClient.connect(rfidConfig.port, rfidConfig.ip, () => {
            tempClient.write(powerCommand);
            tempClient.end();
            clearTimeout(timeout);
            console.log('  ‚úÖ Comando de pot√™ncia enviado via conex√£o tempor√°ria');
            resolve();
          });
          
          tempClient.on('error', (error) => {
            clearTimeout(timeout);
            reject(error);
          });
        });
        
        commandSent = true;
      } catch (tcpError) {
        console.log('  ‚ùå Erro ao enviar comando via conex√£o tempor√°ria:', tcpError.message);
      }
    }
    
    // Atualizar configura√ß√£o local independentemente do resultado
    rfidConfig.power = power;
    console.log(`‚úÖ Configura√ß√£o de pot√™ncia atualizada para ${power} dBm`);
    
    // Emitir atualiza√ß√£o para todos os clientes
    io.emit('power-updated', { power: power });
    
    // Retornar true se pelo menos um m√©todo funcionou, ou se n√£o h√° conex√£o
    return true;
    
  } catch (error) {
    console.error('‚ùå Erro ao aplicar pot√™ncia:', error.message);
    // Mesmo com erro, atualizar a configura√ß√£o local
    rfidConfig.power = power;
    console.log(`‚ö†Ô∏è Erro na aplica√ß√£o, mas configura√ß√£o local atualizada para ${power} dBm`);
    return true; // Retornar true para n√£o causar erro 500
  }
}

// Fun√ß√£o para encerramento gracioso do servidor
function gracefulShutdown(reason) {
  if (isShuttingDown) return;
  isShuttingDown = true;
  
  console.log(`üõë Encerramento gracioso: ${reason}`);
  
  // Parar todos os intervalos
  if (keepAliveInterval) {
    clearInterval(keepAliveInterval);
    keepAliveInterval = null;
  }
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
    connectionCheckInterval = null;
  }
  if (readingHealthCheckInterval) {
    clearInterval(readingHealthCheckInterval);
    readingHealthCheckInterval = null;
  }
  if (memoryCheckInterval) {
    clearInterval(memoryCheckInterval);
    memoryCheckInterval = null;
  }
  
  // Desconectar RFID
  if (isConnected) {
    disconnectFromRFIDReader();
  }
  
  // Fechar servidor HTTP
  server.close(() => {
    console.log('‚úÖ Servidor HTTP fechado');
    process.exit(0);
  });
  
  // Timeout de seguran√ßa
  setTimeout(() => {
    console.log('‚è∞ Timeout de seguran√ßa - for√ßando sa√≠da');
    process.exit(1);
  }, 5000);
}

// Monitoramento de mem√≥ria
function startMemoryCheck() {
  if (memoryCheckInterval) {
    clearInterval(memoryCheckInterval);
  }
  memoryCheckInterval = setInterval(checkMemoryUsage, MEMORY_CHECK_INTERVAL);
  console.log(`üîç Monitoramento de mem√≥ria iniciado (intervalo: ${MEMORY_CHECK_INTERVAL / 1000}s)`);
}

// Fun√ß√£o para verificar uso de mem√≥ria
function checkMemoryUsage() {
  try {
    const memUsage = process.memoryUsage();
    const heapUsed = memUsage.heapUsed;
    const heapTotal = memUsage.heapTotal;
    
    console.log(`üíæ Mem√≥ria: ${Math.round(heapUsed / 1024 / 1024)}MB / ${Math.round(heapTotal / 1024 / 1024)}MB`);
    
    // Se a mem√≥ria estiver muito alta, limpar e for√ßar GC
    if (heapUsed > MAX_MEMORY_USAGE) {
      console.warn('‚ö†Ô∏è Uso de mem√≥ria alto detectado!');
      
      // Limpar arrays grandes
      if (readings.length > MAX_READINGS_LENGTH) {
        readings = readings.slice(-MAX_READINGS_LENGTH);
        console.log('üßπ Array de leituras reduzido para economizar mem√≥ria');
      }
      
      // For√ßar garbage collection se dispon√≠vel
      if (global.gc) {
        global.gc();
        console.log('üóëÔ∏è Garbage collection for√ßado');
      }
      
      // Se ainda estiver alto ap√≥s limpeza, reiniciar
      const newMemUsage = process.memoryUsage();
      if (newMemUsage.heapUsed > MAX_MEMORY_USAGE) {
        console.error('üö® Mem√≥ria ainda alta ap√≥s limpeza! Reiniciando aplica√ß√£o...');
        gracefulShutdown('Mem√≥ria insuficiente');
      }
    }
  } catch (error) {
    console.error('‚ùå Erro ao verificar uso de mem√≥ria:', error.message);
  }
}

// Tratar perda de conex√£o
async function handleConnectionLoss() {
  console.log('üîÑ Detectada perda de conex√£o, tentando reconectar...');
  
  try {
    // Parar intervalos
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
    }
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
    }
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
    }
    if (memoryCheckInterval) {
      clearInterval(memoryCheckInterval);
      memoryCheckInterval = null;
    }
    
    // Marcar como desconectado
    isConnected = false;
    isReading = false;
    receiverAttached = false; // Reset para permitir reconex√£o
    
    // Tentar reconectar
    await connectToRFIDReader();
    
    // Se reconectou com sucesso, N√ÉO iniciar leitura automaticamente
    if (isConnected) {
      console.log('‚úÖ Reconex√£o bem-sucedida! Leitor conectado mas leitura pausada.');
      console.log('‚ÑπÔ∏è Use "Iniciar Leitura" para come√ßar a ler tags.');
      
      // N√ÉO iniciar leitura automaticamente - deixar controle manual
      
      // Emitir status atualizado
      io.emit('connection-status', { 
        isConnected: true,
        isReading: isReading,
        totalReadings: totalReadings,
        uniqueTIDs: uniqueTIDs.size,
        config: rfidConfig
      });
    }
  } catch (error) {
    console.error('‚ùå Falha na reconex√£o:', error.message);
    // Emitir status de desconectado
    io.emit('connection-status', { 
      isConnected: false,
      isReading: false,
      totalReadings: totalReadings,
      uniqueTIDs: uniqueTIDs.size,
      config: rfidConfig
    });
  }
}

// Iniciar leitura cont√≠nua via chainway-rfid
async function startContinuousReading() {
  if (!isConnected) {
    console.log('‚ö†Ô∏è N√£o h√° conex√£o com o leitor');
    return;
  }
  if (isReading) {
    console.log('‚ö†Ô∏è J√° est√° lendo');
    return;
  }
  try {
    console.log(`üü¢ Iniciando leitura cont√≠nua em ${rfidConfig.ip}:${rfidConfig.port}...`);
    console.log(`  ‚ö° Pot√™ncia atual: ${rfidConfig.power} dBm`);
    console.log(`  üì° Antenas ativas: ${rfidConfig.antennas.join(', ')}`);
    
    console.log('  üîç Enviando comando startScan...');
    await chainwayApi.startScan();
    console.log('  ‚úÖ Comando startScan executado com sucesso');
    
    isReading = true;
    lastActivityTime = Date.now(); // Atualizar tempo de atividade
    lastReadingTime = Date.now(); // Registrar in√≠cio da leitura
    console.log('‚úÖ Leitura cont√≠nua iniciada');
    console.log(`  üìä Status: isReading=${isReading}, lastReadingTime=${new Date(lastReadingTime).toISOString()}`);
  } catch (error) {
    console.error('‚ùå Erro ao iniciar leitura:', error.message || error);
    console.error('  üìç Detalhes do erro:', error.stack || 'Stack trace n√£o dispon√≠vel');
  }
}

// Parar leitura cont√≠nua via chainway-rfid
async function stopContinuousReading() {
  // Log de stack trace para identificar quem est√° chamando
  const stackTrace = new Error().stack;
  console.log('üõë stopContinuousReading() chamada por:');
  console.log('  üìç Stack trace:', stackTrace);
  
  if (!isReading) {
    console.log('‚ö†Ô∏è N√£o est√° lendo');
    return;
  }
  try {
    console.log('üõë Parando leitura cont√≠nua...');
    console.log(`  üìä Status antes: isReading=${isReading}, lastReadingTime=${lastReadingTime ? new Date(lastReadingTime).toISOString() : 'null'}`);
    
    console.log('  üîç Enviando comando stopScan...');
    await chainwayApi.stopScan();
    console.log('  ‚úÖ Comando stopScan executado com sucesso');
    
    isReading = false;
    lastActivityTime = Date.now(); // Atualizar tempo de atividade
    lastReadingTime = null; // Limpar tempo de leitura
    console.log('‚úÖ Leitura cont√≠nua parada');
    console.log(`  üìä Status depois: isReading=${isReading}, lastReadingTime=${lastReadingTime}`);
  } catch (error) {
    console.error('‚ùå Erro ao parar leitura:', error.message || error);
    console.error('  üìç Stack trace:', error.stack || 'N√£o dispon√≠vel');
  }
}

// Desconectar do leitor via chainway-rfid
async function disconnectFromRFIDReader() {
  if (!isConnected) return;
  try {
    console.log(`üîå Desconectando do leitor RFID (${rfidConfig.ip}:${rfidConfig.port})...`);
    
    // Parar intervalos de keep-alive
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
      console.log('üîÑ Keep-alive parado');
    }
    
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
      console.log('üîç Verifica√ß√£o de conex√£o parada');
    }
    
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
      console.log('üìä Health check de leitura parado');
    }
    if (memoryCheckInterval) {
      clearInterval(memoryCheckInterval);
      memoryCheckInterval = null;
      console.log('üîç Monitoramento de mem√≥ria parado');
    }
    
    // Verificar se os m√©todos existem antes de chamar
    if (typeof chainwayApi.stopScan === 'function') {
      try {
        await chainwayApi.stopScan();
      } catch (stopError) {
        console.log('‚ö†Ô∏è Erro ao parar scan (n√£o cr√≠tico):', stopError.message);
      }
    }
    
    if (typeof chainwayApi.disconnect === 'function') {
      try {
        await chainwayApi.disconnect();
      } catch (disconnectError) {
        console.log('‚ö†Ô∏è Erro ao desconectar (n√£o cr√≠tico):', disconnectError.message);
      }
    }
    
    isReading = false;
    isConnected = false;
    lastActivityTime = null;
    receiverAttached = false; // Reset para permitir reconex√£o
    console.log('‚úÖ Desconectado do leitor RFID');
  } catch (error) {
    console.error('‚ùå Erro ao desconectar:', error.message || error);
    // For√ßar desconex√£o mesmo com erro
    isReading = false;
    isConnected = false;
    lastActivityTime = null;
    receiverAttached = false; // Reset para permitir reconex√£o
    
    // Limpar intervalos mesmo com erro
    if (keepAliveInterval) {
      clearInterval(keepAliveInterval);
      keepAliveInterval = null;
    }
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
      connectionCheckInterval = null;
    }
    if (readingHealthCheckInterval) {
      clearInterval(readingHealthCheckInterval);
      readingHealthCheckInterval = null;
    }
    if (memoryCheckInterval) {
      clearInterval(memoryCheckInterval);
      memoryCheckInterval = null;
    }
  }
}

// Socket.IO event handlers
io.on('connection', (socket) => {
  console.log('üîå Cliente conectado:', socket.id);
  
  // Enviar status atual
  socket.emit('connection-status', { 
    isConnected: !!isConnected,
    isReading: isReading,
    totalReadings: totalReadings,
    config: rfidConfig
  });

  socket.on('connect-reader', async () => {
    try {
      await connectToRFIDReader();
      socket.emit('connection-status', { 
        isConnected: true,
        isReading: isReading,
        totalReadings: totalReadings,
        config: rfidConfig
      });
    } catch (error) {
      socket.emit('error', { message: 'Erro ao conectar: ' + error.message });
    }
  });

  socket.on('disconnect-reader', () => {
    disconnectFromRFIDReader();
    socket.emit('connection-status', { 
      isConnected: false,
      isReading: false,
      totalReadings: totalReadings,
      config: rfidConfig
    });
  });

  socket.on('start-reading', () => {
    startContinuousReading();
    socket.emit('reading-status', { isReading: true });
  });

  socket.on('stop-reading', () => {
    stopContinuousReading();
    socket.emit('reading-status', { isReading: false });
  });

  socket.on('clear-readings', () => {
    try {
      console.log('üßπ Limpando hist√≥rico de leituras...');
      
      // Limpar arrays e contadores
      readings = [];
      totalReadings = 0;
      uniqueTIDs.clear(); // Limpar TIDs √∫nicos
      
      // Emitir atualiza√ß√£o para todos os clientes
      io.emit('readings-update', { readings, totalReadings, uniqueTIDs: uniqueTIDs.size });
      
      console.log('‚úÖ Hist√≥rico limpo com sucesso');
    } catch (error) {
      console.error('‚ùå Erro ao limpar hist√≥rico:', error.message);
      socket.emit('error', { message: 'Erro ao limpar hist√≥rico: ' + error.message });
    }
  });

  socket.on('disconnect', () => {
    console.log('üîå Cliente desconectado:', socket.id);
  });
});

// REST API endpoints
app.get('/api/status', (req, res) => {
  res.json({
    isConnected: !!isConnected,
    isReading: isReading,
    totalReadings: totalReadings,
    uniqueTIDs: uniqueTIDs.size, // Adicionar contagem de TIDs √∫nicos
    readings: readings.slice(-10), // √öltimas 10 leituras
    config: rfidConfig
  });
});

app.get('/api/readings', (req, res) => {
  res.json({
    readings: readings,
    totalReadings: totalReadings
  });
});

app.get('/api/config', (req, res) => {
  res.json(rfidConfig);
});

app.post('/api/config', async (req, res) => {
  try {
    const newConfig = req.body;
    
    // Validar configura√ß√£o
    if (newConfig.ip && !/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(newConfig.ip)) {
      return res.status(400).json({ success: false, message: 'IP inv√°lido' });
    }
    
    if (newConfig.port && (newConfig.port < 1 || newConfig.port > 65535)) {
      return res.status(400).json({ success: false, message: 'Porta inv√°lida' });
    }
    
    // Validar pot√™ncia (0-30 dBm)
    if (newConfig.power !== undefined) {
      if (newConfig.power < 0 || newConfig.power > 30) {
        return res.status(400).json({ success: false, message: 'Pot√™ncia deve estar entre 0 e 30 dBm' });
      }
      
      // Aviso para pot√™ncias muito altas
      if (newConfig.power > 25) {
        console.log(`‚ö†Ô∏è ATEN√á√ÉO: Pot√™ncia configurada muito alta (${newConfig.power} dBm)`);
        console.log('  ‚ö†Ô∏è Pot√™ncias altas podem causar interfer√™ncia e problemas de estabilidade');
      }
    }
    
    // Validar antenas (array de n√∫meros de 1 a 4)
    if (newConfig.antennas && Array.isArray(newConfig.antennas)) {
      for (const antenna of newConfig.antennas) {
        if (typeof antenna !== 'number' || antenna < 1 || antenna > 4) {
          return res.status(400).json({ success: false, message: 'Antenas devem ser n√∫meros de 1 a 4' });
        }
      }
    }
    
    // Atualizar configura√ß√£o
    const oldConfig = { ...rfidConfig };
    rfidConfig = { ...rfidConfig, ...newConfig };
    
    console.log('‚öôÔ∏è Configura√ß√£o atualizada:');
    console.log('  üì° IP:', oldConfig.ip, '‚Üí', rfidConfig.ip);
    console.log('  üîå Porta:', oldConfig.port, '‚Üí', rfidConfig.port);
    console.log('  ‚ö° Pot√™ncia:', oldConfig.power, '‚Üí', rfidConfig.power, 'dBm');
    console.log('  üì° Antenas:', oldConfig.antennas, '‚Üí', rfidConfig.antennas);
    console.log('  üîä Som:', oldConfig.soundEnabled, '‚Üí', rfidConfig.soundEnabled);
    
    // Se estiver conectado, desconectar para usar nova configura√ß√£o
    if (isConnected) {
      console.log('üîÑ Reconectando com nova configura√ß√£o...');
      try {
        await disconnectFromRFIDReader();
        
        // Apenas reconectar, N√ÉO iniciar leitura automaticamente ap√≥s trocar configura√ß√£o
        console.log('üîÑ Reconectando automaticamente com nova configura√ß√£o...');
        try {
          await connectToRFIDReader();
          console.log('‚úÖ Reconectado com nova configura√ß√£o! Use "Iniciar Leitura" para come√ßar.');
        } catch (reconnectError) {
          console.error('‚ùå Erro na reconex√£o autom√°tica:', reconnectError.message);
          console.log('‚ö†Ô∏è Tentando reconectar novamente em 3 segundos...');
          
          // Tentar reconectar novamente ap√≥s delay
          setTimeout(async () => {
            try {
              await connectToRFIDReader();
              console.log('‚úÖ Reconectado na segunda tentativa!');
            } catch (secondError) {
              console.error('‚ùå Falha na segunda tentativa de reconex√£o:', secondError.message);
            }
          }, 3000);
        }
      } catch (disconnectError) {
        console.log('‚ö†Ô∏è Erro na desconex√£o (n√£o cr√≠tico):', disconnectError.message);
        // Tentar reconectar mesmo com erro
        try {
          await connectToRFIDReader();
          console.log('‚úÖ Reconectado ap√≥s erro na desconex√£o!');
        } catch (reconnectError) {
          console.log('‚ùå Falha na reconex√£o:', reconnectError.message);
        }
      }
    }
    
    res.json({ success: true, message: 'Configura√ß√£o atualizada', config: rfidConfig });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar configura√ß√£o:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

app.post('/api/connect', async (req, res) => {
  try {
    await connectToRFIDReader();
    // Apenas conectar, N√ÉO iniciar leitura automaticamente
    res.json({ success: true, message: 'Conectado ao leitor RFID' });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

app.post('/api/disconnect', (req, res) => {
  disconnectFromRFIDReader();
  res.json({ success: true, message: 'Desconectado do leitor RFID' });
});

app.post('/api/start-reading', (req, res) => {
  startContinuousReading();
  res.json({ success: true, message: 'Leitura iniciada' });
});

app.post('/api/stop-reading', async (req, res) => {
  try {
    await stopContinuousReading();
    
    // Apenas parar leitura, N√ÉO reiniciar automaticamente
    res.json({ success: true, message: 'Leitura parada' });
  } catch (error) {
    res.status(500).json({ success: false, message: error.message });
  }
});

// Nova rota para ajustar apenas a pot√™ncia em tempo real
app.post('/api/power', async (req, res) => {
  try {
    const { power } = req.body;
    
    // Validar pot√™ncia
    if (power === undefined || power < 0 || power > 30) {
      return res.status(400).json({ 
        success: false, 
        message: 'Pot√™ncia deve estar entre 0 e 30 dBm' 
      });
    }
    
    // Aviso para pot√™ncias muito altas
    if (power > 25) {
      console.log(`‚ö†Ô∏è ATEN√á√ÉO: Pot√™ncia solicitada muito alta (${power} dBm)`);
      console.log('  ‚ö†Ô∏è Pot√™ncias altas podem causar interfer√™ncia e problemas de estabilidade');
    }
    
    console.log(`üîå Recebida solicita√ß√£o para ajustar pot√™ncia para ${power} dBm`);
    
    // Aplicar pot√™ncia em tempo real
    const success = await applyPowerInRealTime(power);
    
    if (success) {
      console.log(`‚úÖ Pot√™ncia ajustada com sucesso para ${power} dBm`);
      res.json({ 
        success: true, 
        message: `Pot√™ncia ajustada para ${power} dBm`,
        power: power,
        connected: isConnected
      });
    } else {
      console.log(`‚ùå Falha ao aplicar pot√™ncia ${power} dBm`);
      res.status(500).json({ 
        success: false, 
        message: 'Falha ao aplicar pot√™ncia' 
      });
    }
  } catch (error) {
    console.error('‚ùå Erro ao ajustar pot√™ncia:', error);
    res.status(500).json({ 
      success: false, 
      message: `Erro interno: ${error.message}` 
    });
  }
});

// Limpeza peri√≥dica de mem√≥ria
function cleanupMemory() {
  try {
    // Limpar arrays antigos
    if (readings.length > MAX_READINGS_HISTORY * 2) {
      readings = readings.slice(-MAX_READINGS_HISTORY);
      console.log('üßπ Mem√≥ria limpa - hist√≥rico reduzido');
    }
    
    // For√ßar garbage collection se dispon√≠vel
    if (global.gc) {
      global.gc();
      console.log('üóëÔ∏è Garbage collection executado');
    }
  } catch (error) {
    console.error('‚ùå Erro na limpeza de mem√≥ria:', error.message);
  }
}

// Limpeza a cada 5 minutos
setInterval(cleanupMemory, 300000);

// Tratamento de erro para setInterval
process.on('uncaughtException', (error) => {
  console.error('üö® Erro n√£o capturado:', error);
  gracefulShutdown('Erro n√£o capturado');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üö® Promise rejeitada n√£o tratada:', reason);
  gracefulShutdown('Promise rejeitada n√£o tratada');
});

// Tratamento de encerramento
process.on('SIGINT', () => {
  console.log('\nüõë Encerrando servidor...');
  stopContinuousReading();
  disconnectFromRFIDReader();
  server.close(() => {
    console.log('‚úÖ Servidor encerrado');
    process.exit(0);
  });
});



// Iniciar servidor
server.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando em http://localhost:${PORT}`);
  console.log(`üì° Configura√ß√£o inicial: ${rfidConfig.ip}:${rfidConfig.port}`);
});

